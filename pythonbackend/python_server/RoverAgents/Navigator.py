import time
from Astar import euclidean_distance
class AStarNavigator:
    def __init__(self, angle = 15, wall_threshold = 500):
        self.angle = angle
        self.wall_threshold = wall_threshold
        pass

    def follow_astar_path(self, path, max_run_time = 60, following_strategy='left') -> bool:
        '''
        path: The path generated by using A*
        max_run_time: max running time before timeout
        '''
        
        for i, point in enumerate(path):
            start_time = time.time()
            if(time.time() - start_time > max_run_time):
                print("timeout reached.")
                return False

            print(f"Heading to point {point}...")
            
            while not self.is_at_next_point(point):
                distance = self.get_obstacle_distance()

                if distance > 100 & distance <= 500:
                    self.set_throttle(0.5)
                elif distance <= 100:
                    next_node = point
                    self.wall_following(side=following_strategy, next_node=next_node)
                else:
                    self.set_throttle(1.0)
                    self.set_brake(False)

                dir = self.compute_dir_to_next_point(point)
                self.set_dir(dir)

                time.sleep(1)
            print("Reached point {point}.")

        print("Goal Reached")
        self.set_throttle(0)
        self.set_brake(True)
        return True

    def is_at_next_point(self, point, threshold=1):
        '''
        Check if reaching the next given point.
        threshold: distance threshold
        return: bool
        '''
        cur_pos = self.get_cur_pos()
        distance = euclidean_distance(cur_pos, point)
        return distance <= threshold

    def compute_dir_to_next_point(self,point):
        '''
        Compute the direction reuqired to travel toward the next point
        '''
        #TODO
        return 0.0

    def wall_following(self, strategy, next_node):
        '''
        Follow the obstacle on a particular side until we realign with the path
        strategy: 'left' or 'right'
        next_node: the x and y coordinate we are trying to reach again
        angle: The adjustment for each turn in degrees
        '''
        #TODO Finish implement Use the Lidar reading 7(left)/8(right) to check if a wall is present, if not turn in following direction till on a wall
        side_sensor = 7 if strategy == 'left' else 8
        while True:
            cur_heading  = self.get_cur_dir()
            distance = self.get_lidar_reading(side_sensor)
            if strategy == 'left':
                adjusted_heading = cur_heading - self.angle
            else:
                adjusted_heading = cur_heading + self.angle
            
            self.set_dir(adjusted_heading)

            if self.if_realigned(next_node):
                break
            
            time.sleep(0.5)

    def get_lidar_reading(self, sensor_id) -> float:
        '''
        Get lidar data from specified lidar number
        
        sensor_id: speicified lidar number
        Return: lidar data
        '''
        #TODOs
    def if_realigned(self,next_node, threshold=1):
        pos = self.get_cur_pos()
        return abs(pos[0] == next_node[0]) < threshold or abs(pos[1] == next_node[1]) < threshold

    def get_cur_pos(self):
        '''
        Get the vehicle's current position
        '''
        #TODO: Use the TSS to poll for co-ordinates
        return (0, 0)

    def set_dir(self, dir):
        '''
        set the steering direction.
        '''
        #TODO: Need to test how steering value affects facing angle, send TSS direction
        pass

    def get_cur_dir(self):
        '''
        Return the current direction of Rover
        '''
        #TODO: Use the IMU to determine velocity direction

    def get_obstacle_distance(self):
        '''
        Return the distance to the nearest obstacle
        '''
        #TODO: Loop through all obstacles and find the closest one (a seperate SLAM file with obstacles can help)
        return 1000

    def set_throttle(self, speed):
        '''
        Set the throttle to a sertain speed
        '''
        #TODO: Send request to TSS with throttle value
        pass

    def set_brake(self, is_braking):
        '''
        Braking control
        '''
        #TODO: Send request to TSS with braking value
        pass

