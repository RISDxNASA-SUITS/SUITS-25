import time
from Astar import astar

def follow_astar_path(path, max_run_time = 60, following_strategy='left'):
    '''
    path: The path generated by using A*
    max_run_time: max running time before timeout
    '''
    
    for i, point in enumerate(path):
        start_time = time.time()
        if(time.time() - start_time > max_run_time):
            print("timeout reached.")
            break

        print(f"Heading to point {point}...")
        
        while not is_at_next_point(point):
            distance = get_obstacle_distance()

            if distance > 100 & distance <= 500:
                set_throttle(0.5)
            elif distance <= 100:
                next_node = point
                wall_following(side=following_strategy, next_node=next_node)
            else:
                set_throttle(1.0)
                set_brake(False)

            dir = compute_dir_to_next_point(point)
            set_dir(dir)

            time.sleep(1)
        print("Reached point {point}.")

    print("Goal Reached")
    set_throttle(0)
    set_brake(True)

def is_at_next_point(point, threshold=1):
    '''
    Check if reaching the next given point.
    threshold: distance threshold
    return: bool
    '''
    cur_pos = get_cur_pos()
    distance = astar.euclidean_distance(cur_pos, point)
    return distance <= threshold

def compute_dir_to_next_point(point):
    '''
    Compute the direction reuqired to travel toward the next point
    '''
    #TODO
    return 0.0

def wall_following(strategy, next_node, angle=15):
    '''
    Follow the obstacle on a particular side until we realign with the path
    strategy: 'left' or 'right'
    next_node: the x and y coordinate we are trying to reach again
    '''
    #TODO Finish implement
    while True:
        cur_heading  = get_cur_dir()
        if strategy == 'left':
            adjusted_heading = cur_heading - angle
        elif strategy == 'right':
            adjusted_heading = cur_heading + angle
        else:
            adjusted_heading = cur_heading
        
        set_dir(adjusted_heading)

        if if_realigned(next_node):
            break
        
        time.sleep(0.5)


def if_realigned(next_node, threshold=1):
   pos = get_cur_pos()
   return abs(pos[0] == next_node[0]) < threshold or abs(pos[1] == next_node[1]) < threshold

def get_cur_pos():
    '''
    Get the vehicle's current position
    '''
    #TODO
    return (0, 0)

def set_dir(dir):
    '''
    set the steering direction.
    '''
    #TODO
    pass

def get_cur_dir():
    '''
    Return the current direction of Rover
    '''

def get_obstacle_distance():
    '''
    Return the distance to the nearest obstacle
    '''
    #TODO
    return 1000

def set_throttle(speed):
    '''
    Set the throttle to a sertain speed
    '''
    #TODO
    pass

def set_brake(is_braking):
    '''
    Braking control
    '''
    #TODO
    pass


                    




